// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title Stores and compares hashes of encrypted models between model owners and cloud providers
/// @author Jackson Bullard
contract ModelConfirmation {
	// Maps cloud provider to model hash generated by model owner
	mapping (address => Confirmation[]) public cloudProviderToModel;

	// Stores the model hash generated by the model owner
	// and whether the cloud provider's hash has been verified
	struct Confirmation {
		address modelOwner;
		bytes32 modelHash;
		bool verifiedHash;
	}

	/**
	 * @notice For model owners; map hash of encrypted model to the intended cloud provider
	 * @param _modelHash The keccak256 hash of the encrypted model held by the model owner
	 * @param _cloudProvider The address of the cloud provider that the encrypted model was sent to
	 */
	function mapProviderToModel(bytes32 _modelHash, address _cloudProvider) external {
		Confirmation[] memory mappedHashes = cloudProviderToModel[_cloudProvider];
		bool roundUpdated = false;

		for (uint32 i = 0; i < mappedHashes.length; i++) {
			// Prevent duplicate mappings of models
			require(mappedHashes[i].modelHash != _modelHash, "Duplicate requests forbidden.");

			// Round update for existing model owner-cloud provider relationship
			if (mappedHashes[i].modelOwner == msg.sender) {
				cloudProviderToModel[_cloudProvider][i] = Confirmation(msg.sender, _modelHash, false);
				roundUpdated = true;
				
				break;
			}
		}

		// Executes when the model owner (msg.sender) has not previously mapped a model to _cloudProvider
		if (!roundUpdated) {
			Confirmation memory confirmation = Confirmation(msg.sender, _modelHash, false);
			cloudProviderToModel[_cloudProvider].push(confirmation);
		}
	}

	/**
	 * @notice For cloud providers; Determines whether model was transferred successfully
	 * from model owner to cloud provider by comparing hashes.
	 *
	 * @param _modelHash The keccak256 hash generated by the cloud provider using the received model
	 */
	function verifyModelHash(bytes32 _modelHash) external {
		Confirmation[] memory mappedHashes = cloudProviderToModel[msg.sender];

		for (uint32 i = 0; i < mappedHashes.length; i++) {
			// Compare hashes
			if (mappedHashes[i].modelHash == _modelHash) {
				cloudProviderToModel[msg.sender][i].verifiedHash = true;
				break;
			}
		}
	}

	/**
	 * @dev Function mostly for diagnostic purposes
	 * @param _cloudProvider Address of cloud provider
	 * @return Array of confirmations mapped to the given cloud provider address
	 */
	function getModelConfirmations(address _cloudProvider) public view returns (Confirmation[] memory) {
		return cloudProviderToModel[_cloudProvider];
	}
}
