// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "./ModelMoments.sol";

/// @title Stores and compares hashes of encrypted models between model owners and cloud providers
/// @author Jackson Bullard
contract ModelConfirmation is ModelMoments {
	/// @notice Maps cloud provider to model hash generated by model owner
	mapping (address => Confirmation[]) public cloudProviderToModel;

	/// @notice Stores the model hash generated by the model owner and whether the cloud provider's hash has been verified
	struct Confirmation {
		uint256 modelHash;
		bool verifiedHash;
	}

	/// @notice For model owners; map hash of encrypted model to the intended cloud provider
	/// @param _modelHash The keccak256 hash of the encrypted model held by the model owner
	/// @param _cloudProvider The address of the cloud provider that the encrypted model was sent to
	function mapProviderToModel(uint256 _modelHash, address _cloudProvider) external {
		// TO-DO: Enforce authorized model owners only
		// TO-DO: Ensure duplicate confirmations do not occur
		Confirmation memory confirmation = Confirmation(_modelHash, false);
		cloudProviderToModel[_cloudProvider].push(confirmation);
	}

	/**
		@notice For cloud providers; determine whether model was transferred successfully
			from model owner to cloud provider by comparing hashes.
	*/
	/// @param _modelHash The keccak256 hash generated by the cloud provider using the received model
	function verifyModelHash(uint256 _modelHash) external {
		Confirmation[] memory mappedHashes = cloudProviderToModel[msg.sender];

		for (uint i = 0; i < mappedHashes.length; i++) {
			// Compare hashes
			if (mappedHashes[i].modelHash == _modelHash) {
				cloudProviderToModel[msg.sender][i].verifiedHash = true;
				break;
			}
		}
	}
}
